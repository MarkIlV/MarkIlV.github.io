{"meta":{"title":"N0us's Blog","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Bugku Web 部分题解","slug":"Bugku","date":"2020-03-22T14:03:02.000Z","updated":"2020-03-22T14:04:03.001Z","comments":true,"path":"2020/03/22/Bugku/","link":"","permalink":"http://yoursite.com/2020/03/22/Bugku/","excerpt":"","text":"Bugku Web 部分题解一、秋名山老司机题目地址：戳我 打开网址发现是这样的，要求在2s内计算表达式，这类题很常见，思路就是抓取HTML，正则提取表达式，计算然后post回去数据就可以 解题脚本如下： 123456789101112import reimport requestsurl = 'http://123.206.87.240:8002/qiumingshan/'s=requests.Session()response = s.get(url)reg = re.compile(r'[0-9+\\-*]&#123;3,&#125;[0-9]')result = reg.findall(response.text)data = &#123;'value':eval(result[0])&#125;reps = s.post(url,data = data)print(reps.content.decode('utf-8')) 查看结果即可得到flag 二、速度要快题目地址：戳我 打开后发现只有一行字 F12查看源代码： 12345&lt;body&gt; &lt;br&gt; 我感觉你得快点!!! &lt;!-- OK ,now you have to post the margin what you find --&gt;&lt;/body&gt; 看到让我们Post margin的值，发现margin等于8，打开hackbar post过去，发现返回是这样的： 打开burpsuite查看response，发现有flag，喜出望外但觉得事情不会这么简单🤔 base64解码一下： 1跑的还不错，给你flag吧: NTM1ODcw 但填入发现flag是错误的，参考大佬的WP发现原来这个flag的值是变化的，亲自burp repeat数次之后发现确实如此，于是乎上脚本： 1234567891011121314import requestsimport base64url = 'http://123.206.87.240:8002/web6/'s = requests.Session()headers = s.get(url).headersresult = base64.b64decode(headers['flag'])result = result.decode()flag = base64.b64decode(result.split(':')[1])data = &#123;'margin':flag&#125;print(s.post(url,data).text) 得到的返回即是flag： 三、md5 collision(NUPT_CTF)题目地址：戳我 这道题其实很简单，只需要知道一个知识点：PHP在处理哈希字符串时，会用“==”或“!=”比较哈希值，它会把每一个以“0E”开头的值解释为零，所以对于两个不同的密码，如果经过哈希以后，他们都是已0E开头的，那么PHP会认为它们是相等的，都是0 知道了这一点，这道题就很简单了，只需要找给a传一个经过哈希以后是0E开头的密码就可以，下面是一些以0E开头的哈希值及其原密码（参考：https://blog.csdn.net/qq_40647424/article/details/88088601）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 任意传入一个即可拿到flag： 四、各种绕过题目地址：戳我 打开题目，发现过滤代码： 12345678910111213141516171819&lt;?phphighlight_file('flag.php');$_GET['id'] = urldecode($_GET['id']);$flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;';if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!';&#125;?&gt; 观察代码得知，得到flag的条件是$_GET[‘uname’] != $_POST[‘passwd’]并且sha1($_GET[‘uname’]) === sha1($_POST[‘passwd’]) 此时就需要用sha1()函数的漏洞绕过，把这两个字段构造为数组： Execute得到flag：","categories":[{"name":"Writeup","slug":"Writeup","permalink":"http://yoursite.com/categories/Writeup/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"http://yoursite.com/tags/Writeup/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"从头开始设计自己的vscode主题插件","slug":"VsCode_Theme","date":"2020-03-22T14:00:03.000Z","updated":"2020-03-22T14:02:41.034Z","comments":true,"path":"2020/03/22/VsCode_Theme/","link":"","permalink":"http://yoursite.com/2020/03/22/VsCode_Theme/","excerpt":"","text":"0x00.缘起折腾是技术宅的美德，作为一个vscode的深度使用者以及一个挑剔的人，vscode扩展商店里的众多主题我都不是很喜欢，唯独有一款名为Darktooth theme的主题我一直很喜欢，它的配色正是我喜欢的风格，而转折发生在使用vscode书写markdown之后，我发现这款主题并不支持markdown的语法高亮，而在扩展商店搜寻许久也没找到看着特别喜欢的主题，遂决定自行开发一款自己的主题，于是就有了All-Gray的故事 下载地址：VsCode扩展商店地址Github地址 下面来具体说说怎么开发，我回先说怎么去开发插件，然后再说插件的发布 0x01.主题插件的开发（1）安装扩展生成器在命令行执行以下命令安装（注意你一定要有npm环境，没有的话可以上网搜下怎么安装，很简单，不再赘述）： install -g yo generator-code ```1234进入（Windows下）&#96;&#96;&#96;C:\\Users\\lenovo\\.vscode\\extensions&#96;&#96;&#96;目录，输入&#96;&#96;&#96;yo code 命令来运行代码生成器： 我们用上下键选择第三项 New Color Theme Enter 进入，这时候他会问你是从头开始新建一个新主题还是还是导入一个主题在它上面修改，由于我们是完全自己设计，故选择第一个： 这是后它会问你这几个问题，第一个是你扩展的名字是什么，第二个问你扩展的标识是什么，第三个问描述，第四个问你希望用什么名字展示给使用者，即你在扩展商店发布后的名字，这里如无特殊需要，第一二四个问题填你起的名字即可，第三个填写简单的描述就可以，暂时不填也可，在文件里填写就行 成功后大致如下： （2）配置主题根据提示，先输入 cd test（这里你的文件名） 进入扩展文件夹，然后 code . 会发现打开了vscode,目录树如下： 1234567891011│ .vscodeignore│ CHANGELOG.md│ package.json│ README.md│ vsc-extension-quickstart.md│├─.vscode│ launch.json│└─themes Test-color-theme.json 这里我们需要配置的是 themes 目录下的 Test-color-theme.json文件,打开： 这里的每一个配置项对应的是vscode编辑器的一个个scope，比方说Comment对应的是你注释的颜色，你可以根据自己的设计方法配置，但问题来了，难道我们只能在这里配置而不能实时的一遍配置一遍看效果吗，当然不会，你只需要F5 开始调试，然后，即可打开一个新的处于调试模式下的vscode窗口： 打开之后，使用 Ctrl+Shift+P 进入vscode的命令窗口，输入 Developer:Inspect Editor Tokens and Scopes 进入开发者模式，检查编辑器和标记作用域模式，这时候你会发现点击你调试窗口中你想修改的部分，会出现相关的scope信息 这个时候你就可以根据自己的想法，或者去一些设计配色网站找到自己喜欢的配色方案进行修改了，只需要将你想修改的作用域在配置文件中找到，然后将其中的颜色配置改为你喜欢的颜色的值就可以，需要注意的是，这里的颜色填的是颜色的十六进制数值，还有关于字体的设置，是由 fontstyle 属性控制的： 它有八个值，意思也很明确不在赘述，若果你想为某个作用域配置字体设置而它原本没有这一项的话只需要自行加上即可 （3)关于如何去设计一个有多个版本（如dark版和light版）的主题我们在使用别人的主题是可能会发现，某个主题有两三个甚至七八个版本，但生成器生成的却只有一个版本，那么如何去给自己的扩展增加一个版本而不是再去创建一个扩展项目呢，其实很简单，首先我们打开 package.json文件，大约是这样的： 我们只需要先把之前修改的Themes文件夹里面的文件先复制一份，改为这个版本的名称，然后再package.json文件的themes属性下增加一项即可，例如你想增加一个light版的主题，只需要像下面这样即可，注意要将uiTheme改为vs，vs表示的是该主题为light版，uiTheme共有三个值，除了我们已经用到的两个，还有一个设置的是高对比度主题： 注意你复制后的Themes文件夹里的配置新版本主题的json文件中，type一项要改为light： 关于package.json文件，你可以在其中设置你的项目GitHub地址，版权信息，发布者名称，description，还有图标文件的信息之类的发布信息例如下面就是我All-gray的配置： 本文不会教你怎么去设计一个主题，所以这一部分就到这里了，有什么问题欢迎留言讨论 0x02.主题插件的发布（1）注册Azure的开发者账号并设置tokenAzure 点击上面的链接进入Azure 开发者服务网站注册一个账号，你可以使用电子邮件，也可以使用GitHub关联注册，都可以，注册完成后新建一个Public项目 完成之后，点击你的个人设置，选择Personal Access Tokens 进入之后新建一个Token，Name写你的id即可，注意Organization一定要如图选，不然一会可能会连不上，然后点击图中1处，找到MarketPlace项如图配置 点击Create，他会给你一个Token，复制并保存下来，这是唯一保存的机会 （2）安装 vsce 并使用其来发布扩展打开命令行，进入你扩展的目录，使用以下命令安装vsce install -g vsce```1234安装完成后，使用以下命令来创建一个vsce账户：&#96;&#96;&#96;vsce create-publisher (发布者的名字) 注意Windows下可能会有这样的问题： 根据官方文档，这是由于Windows的一些对执行政策的配置导致的，你可以按照下面的方法来解决： 首先使用以下命令查看当前的执行策略： -List```12输出大概如下： Scope ExecutionPolicy —– —————MachinePolicy Undefined UserPolicy Undefined Process Undefined CurrentUser Undefined LocalMachine AllSigned 12在这种情况下，有效的执行策略是 **RemoteSigned** 所以可以执行以下命令更改执行策略： Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 123456789101112执行之后应该就可以连接了成功之后大约会是下面这样：![image](http:&#x2F;&#x2F;picture.2er0blog.com&#x2F;images&#x2F;2020&#x2F;02&#x2F;15&#x2F;image6e07fc605bcbd622.png)这里Email填写你的注册邮箱即可，Token使用你刚才保存的token成功之后，进入你的扩展目录，使用以下命令现将你的扩展打包成vsix文件&#96;&#96;&#96;vsce package 然后直接使用以下命令即可发布： vsce publish 再过几分钟就可以在扩展商店搜索到自己的插件了 本文到这里就全部结束了，各位有什么问题欢迎留言讨论 参考资料 https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7https://juejin.im/post/5cb810d651882532525a0c95https://code.visualstudio.com/api/working-with-extensions/publishing-extension","categories":[{"name":"Misc","slug":"Misc","permalink":"http://yoursite.com/categories/Misc/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}]},{"title":"CVE-2019-1338复现","slug":"CVE-2019-1338复现","date":"2020-03-22T13:31:59.000Z","updated":"2020-03-22T13:58:40.274Z","comments":true,"path":"2020/03/22/CVE-2019-1338复现/","link":"","permalink":"http://yoursite.com/2020/03/22/CVE-2019-1338%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"一、Description“An elevation of privilege vulnerability exists in the Windows Certificate Dialog when it does not properly enforce user privileges, aka ‘Windows Certificate Dialog Elevation of Privilege Vulnerability’. ” 该漏洞存在于UAC（User Account Control，用户账户控制）机制中，利用它可以将Guest权限提升到System 默认情况下，Windows会在一个单独的桌面上显示所有UAC的提示，即Secure Desktop（安全桌面），这些提示由名为consent.exe的可执行文件产生，该文件以NT AUTHORITY\\SYSTEM权限运行，完整性为System 由于用户可以与此界面进行交互，故低权限用户可以通过UI操作的circuit回路径以System的身份进行操作 二、影响范围 Microsoft Windows Server 2019 Microsoft Windows Server 2016 Microsoft Windows Server 2012 Microsoft Windows Server 2008 R2 Microsoft Windows Server 2008 Microsoft Windows RT 8.1 Microsoft Windows 8.1 Microsoft Windows 7 三、复现环境：Win7 HHUPD下载：https://github.com/jas502n/CVE-2019-1388.git 首先使用Guest用户进入系统 打开cmd查看权限 打开用户账户控制程序，可以发现没有多余的可交互的按钮 点击“显示详细信息”，发现出现了一个“显示有关此发布者的证书的信息” 点进去看一下，发现是一个证书的详细信息，并且在“常规”选项的“颁发者”处存在一个超链接 关于证书对话框处的超链接：证书对话框定义了一个Microsoft特定对象标识符（Object Identifier，OID），数值为 1.3.6.1.4.1.311.2.1.10 。WinTrust.h header将其定义为SPC_SP_AGENCY_INFO_OBJID，其如果存在，就会展示名为SpcSpAgencyInfo的详情tab页。该证书对话分析了该OID的值，如果它找到有效的格式正确的值，将使用它将“颁发者”字段的值呈现为超链接，而微软忘记禁用涉及证书对话的UAC版本的超链接 点击此超链接，点击一次后，浏览器并没有弹出，此时应该点击确定，然后点击否，浏览器弹出 点击IE工具栏的“页面”选项，选择“另存为”，此时弹出这样的窗口 点击确定，然后文件名栏输入“C:\\Windows\\System32*.*” 点击“保存”，进入目录 在C:\\Windows\\System32目录里面找到cmd，右键打开，检查权限 发现此时权限已经成功提升为System 四、声明本文中提到的漏洞利用Poc仅供交流学习，请读者遵守《网络安全法》等相关法律法规","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"http://yoursite.com/tags/CVE/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]}]}